<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search for somebody</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <center>
        <h1>Search For a Random Programmer</h1>
        <br>
        <div style="width:300px;"> <!--  Force this button to not take up 100% Width  -->
            <a onclick="searchButtonClicked()" class="search-button"><span id="StartSearchingButtonText">Start Coding</span></a>
        </div>
        <br>
        <span id="searchingForPeopleLoader" class="loader hidden"></span>
    </center>

    <script src="../peerjs.min_1.5.4.js"></script>
    <script src="../js/helping-functions.js"></script>

    <script>
        var searchingButton = document.getElementById("StartSearchingButtonText")
        var searchingForPeopleLoader = document.getElementById("searchingForPeopleLoader")
        
        var isSearching = false
        var searchStateChange = ()=>{}
        function searchButtonClicked(){
            isSearching = !isSearching
            searchingButton.innerText = isSearching ? "Stop Searching" : "Start Coding"
            
            if(isSearching){
                searchingForPeopleLoader.classList.remove("hidden")
            }
            else{
                searchingForPeopleLoader.classList.add("hidden")
            }
            
            try{
                searchStateChange(isSearching)
            }
            catch{}
        }
    </script>
    
    <script>
        const searchingForPeerServerCode = "CWRP-SearchForPeer"
        const myUUID = `${generateRandomString(16, UUID_CHARACTERS)}-${Date.now()}` // from helping-functions
        var isIdTakenCache = {}
        
        function isPeerIdTaken_CreatePeerChecker(peerID){
            var checkPeerIDPeer = new Peer(peerID)
            isIdTakenCache[peerID] = null
            checkPeerIDPeer.on("open", (id) => {
                // not taken b/c we can use it
                checkPeerIDPeer.destroy()
                isIdTakenCache[peerID] = false
            })
            checkPeerIDPeer.on("error", (err) => {
                if (err.type == "unavailable-id") {
                    checkPeerIDPeer.destroy()
                    isIdTakenCache[peerID] = true
                    return true
                }
            })
        }
        
        async function isPeerIdTaken(peerId){
            isPeerIdTaken_CreatePeerChecker(peerId)
            while (isIdTakenCache[peerId] == null) {
                await new Promise((resolve) => setTimeout(resolve, 100));
            }
            return isIdTakenCache[peerId];
        }

        function reloadPage(){
            window.location.reload()
        }

        // after 5 minutes of being host, we will refresh the page
        // so if there is a malicious actor as the host this'll give us a chance to overthrow him
        // TODO: Maybe we add a thing here side to prevent him from instantly connecting and make them wait like 3 seconds
        setInterval(()=>{
            if(amIHost){
                reloadPage()
            }
        }, 5 * 60 * 1000)

        // TODO: When we kick the old host for being host for too long and when we refresh b/c the host left ^^^^
        //     lets not just refresh but instead add a url param saying that we wanted to be automatically be
        //     put back in queue. So don't need to keep clicking the button if the server host keeps leaving (probably by finding a pair)

        var peer
        var connection
        var allConnections = []
        var amIHost = false
        var availableServers = {}
        
        // TODO: Make this check all people searching for a partner and find a random one.
        // Then we can send a requesting packet to the main host (or just the person to pair to if we're the host)
        // The person we requested to can then accept or deny this
        //     Deny: We start looking for people again
        //     Accept (for both parties): We remove ourselves from the availableServers
        //         and then go to the actual page for coding, with a URL param of the other person's UUID & our own
        //         there we'll start a peer.js w/ our UUID and try to connect to the other's UUID, and the rest is handled on the other page
        var searchForOtherPersonCooldownBase = 1000
        function searchForOtherPerson(){
            // only do all of this if we are actively searching.
            if (availableServers[myUUID] == false) { return }

            uuidsToCheck = Object.keys(availableServers)
            // I don't exist in the availableServers. This can only mean that I've never clicked the button, meaning I am not searching
            if (uuidsToCheck.includes(myUUID) == false) { return }

            searchingUUIDs = [] // UUIDs of people that are also searching

            for (let i = 0; i < uuidsToCheck.length; i++) {
                checkingUUID = uuidsToCheck[i]
                // We cannot pair w/ ourselves, so skip us
                if (checkingUUID == myUUID) { continue }
                // "true" means that the other person is also searching
                if (availableServers[checkingUUID] == true) {
                    searchingUUIDs.push(checkingUUID)
                }
            }

            uuidToTryAndPair = searchingUUIDs[randomNumberInclusiveInclusive(0, searchingUUIDs.length - 1)]

            console.log(uuidToTryAndPair)
            // do sending the request packet

            // vary the time so not everyone tries to search at the same instant, letting connections be easier in theory
        }
        function searchForOtherPersonHandler(){
            searchForOtherPerson()
            setTimeout(searchForOtherPersonHandler, searchForOtherPersonCooldownBase + randomNumberInclusiveInclusive(0, 2000))
        }
        searchForOtherPersonHandler()

        function handlePacket(packetData, sendingConnection){
            console.log("Data received: ")
            console.log(packetData)

            // Check if the packets are good, but only if we're host b/c we'll just accept all the host's packets as truth
            if(amIHost){
                if(packetData["UUID"] != sendingConnection.peer){
                    // this packet is not good. There is a mismatch between the packet's claimed sender, and it's real sender
                    // lets reject this by doing nothing and ending the function here
                    return
                }
            }

            // TODO: Make a dictionary w/ the keys being packet types, then the value will be json
            //      saying wether if a packet should be verified, and if it should be forwarded to everyone.

            if(amIHost){
                if (data["Type"] == "SearchingStatusUpdate") {
                    if (data["UUID"] != connection.peer) {
                        console.log("Something fishy is going on here... Looks like they're updating their status. but the sender is not who they claim to be?")
                        // Something fishy is going on here... Looks like they're updating their status
                        //     but the sender is not who they claim to be?
                        // TODO: Add a possible punishment for this? We don't have to since it won't have an effect
                    }
                    else {
                        sendAllConnections(data)
                    }
                }
            }


            var packetType = packetData["Type"]
            switch (packetType) {
                case "SearchingStatusUpdate":
                    var isSearching = packetData["IsSearching"]
                    var whoIsBeingUpdated = packetData["UUID"]
                    availableServers[whoIsBeingUpdated] = isSearching
                    break
                case "AllAvailablePeople":
                    if(amIHost){
                        // Why are we receiving this? We're the host, the only person that should send this.
                        // I think something malicious is happening?
                        console.log("Why are we receiving an \"AllAvailablePeople\" packet? We're the host, the only person that should send this. I think something malicious is happening?")
                        break
                    }
                    availableServers = packetData["AvailablePeople"]
                    break
                default:
                    console.log("idk what type of packet this is ¯\\_(ツ)_/¯ | Packet:")
                    console.log(packetData)
                    break
            }
        }


        function sendAllConnections(data) {
            for (var i = 0; i < allConnections.length; i++) {
                var conn = allConnections[i]
                if(conn._open == false){ continue }
                conn.send(data)
            }
        }

        function sendAllAvailablePeoplePacket(){
            if (amIHost) {
                sendAllConnections({
                    "Type": "AllAvailablePeople",
                    "AvailablePeople": availableServers,
                    "UUID": myUUID
                })
            }
        }

        async function main(){
            var isIdTaken = await isPeerIdTaken(searchingForPeerServerCode)
            var myId = isIdTaken ? myUUID : searchingForPeerServerCode
            // it's possible that if two people join when no one is the host then they'll both see that there is no server
            // so they'll both try and become it. Luckily only one can, so the other one will error out and refresh the page.
            // Also we'll use the UUID as their ID to solve some issues like verifying packets

            peer = new Peer(myId);
            connection = null
            peer.on("open", (id) => {
                amIHost = id == searchingForPeerServerCode

                console.log('My peer ID is: ' + id);
                if(amIHost == false){
                    // We are a random ID, not the central server host...
                    connection = peer.connect(searchingForPeerServerCode)
                    establishConnection(connection)
                }
            })

            peer.on("error", (err)=>{
                console.log("An error occurred! " + err.message)
                console.error(err)
                reloadPage()
            })

            peer.on("connection", (conn) => {
                console.log("Connection:")
                console.log(conn)
                establishConnection(conn)
            })

            function establishConnection(connection) {
                allConnections.push(connection)
                connection.on("open", () => {
                    connection.on("data", (data)=>{
                        handlePacket(data, connection)
                    })

                    searchStateChange = (isSearching)=>{
                        sendAllConnections({
                            "Type": "SearchingStatusUpdate",
                            "IsSearching": isSearching,
                            "UUID": myUUID,
                        })
                        // ^^^ Send to all b/c if we're the central server then we want to send to everyone. It can't hurt to do so anyways
                        
                        availableServers[myUUID] = isSearching
                    }

                    sendAllAvailablePeoplePacket()
                    //connection.send("Hello world! " + peer.id)
                })

                connection.on("close", ()=>{
                    console.log(`Connection closed : ${connection.peer}`)
                    delete availableServers[connection.peer]
                    sendAllAvailablePeoplePacket()

                    //if(peer.id != searchingForPeerServerCode){
                    // this new if statement seems like a better way to check if someone needs to claim the host
                    if(amIHost == false){
                        // Seems like the searching server was either closed or kicked us.
                        // We are going to reload the page to reconnect and/or claim to be the host of the server
                        reloadPage()
                    }
                })
            }
        }

        // put everything into a main function so we can use async code w/o making this script's type "module"
        main()
    </script>
</body>
</html>